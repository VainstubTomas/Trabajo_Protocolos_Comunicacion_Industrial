<div class="card shadow p-3 mb-5 bg-body-tertiary rounded">
    <h1 class="display-1">Industrial control panel</h1>

    <section>
        <h2 class="display-2">Input controls - LED</h2>
        
        <div id="inputsForControl">
    
            {{!-- analog ctrl --}}
            <form id="analogControl" class="d-flex gap-2 mb-3"> 
                <input class="form-control" type="text" id="analogValue" placeholder="Input a new analog value" required>
                <button id="analogButton" class="btn btn-dark" type="submit">Send</button>
            </form>
            
            {{!-- digital ctrl --}}
            <button id="digitalControl" class="btn btn-danger" data-state="0" type="button">OFF</button>
            
        </div>

    </section>

    <h2 class="display-2">Display I/O values</h2>

    <section id="displayInputAndOutputs">
        

        <div class="io-data">
            <p><b>Pot:</b> <span id="currentPot">--</span></p>
        </div>
        <div class="io-data">
            <p><b>Distance:</b> <span id="currentDistance">--</span> cm</p>
        </div>
        <div class="io-data">
            <p><b>Boton 1:</b> <span id="currentBoton1">--</span></p>
        </div>
        <div class="io-data">
            <p><b>Boton 2:</b> <span id="currentBoton2">--</span></p>
        </div>
    </section>

    <h2 class="display-2">Communications states</h2>

    <section id="communicationsStatus">
        
        {{!-- en esclavo y maestro --}}
        <div id="modbusSlaveStatus">
            <p>
                <b>Modbus Slave state:</b> 
                <span id="modbusSlaveState" style="color: rgb(185, 185, 0);">DEVICE NOT REACHED</span>
            </p>
        </div>
        <div id="modbusMasterStatus">
            <p>
                <b>Modbus Master state:</b>
                <span id="modbusMasterState" style="color: rgb(185, 185, 0);">DEVICE NOT REACHED</span>
            </p>
        </div>

        <div id="modbusEstadistica">
            <p>
                <b>Modbus statistics (A/CRC/E):</b>
                <span id="modbusEstadisticaAceptado">--</span>
                <span id="modbusEstadisticaCRC">--</span>
                <span id="modbusEstadisticaNoAlcanzado">--</span>
            </p>
        </div>

        {{!-- cliente y servidor --}}
        <div id="opcServerStatus">
            <p>
                <b>OPC Server state:</b> 
                <span id="opcServerState" style="color: red";>ERROR</span>
            </p>
        </div>
        <div id="opcClientStatus">
            <p>
                <b>OPC Client state:</b> 
                <span id="opcClientState" style="color: red";>ERROR</span>
            </p>
        </div>
        <div id="mqttStatus">
            <p>
                <b>MQTT state:</b> 
                <span id="mqttState">CONNECTED</span>
            </p>
        </div>
    </section>
{{!-- 
    <section id="failsControl">
        <h2 class="display-2">System failures</h2>
    </section> --}}
</div>

{{!-- websocket connection --}}
<script src="/socket.io/socket.io.js"></script>

<script>
    //client/server connection
    const socket = io();

    //DOM
    const modbusAceptada = document.getElementById("modbusEstadisticaAceptado");
    const modbusCRC = document.getElementById("modbusEstadisticaCRC");
    const modbusNoAlcanzada= document.getElementById("modbusEstadisticaNoAlcanzado");
    const botonAnalogico = document.getElementById("analogButton");
    const botonLED = document.getElementById("digitalControl");
    const boton1 = document.getElementById("currentBoton1");
    const boton2 = document.getElementById("currentBoton2");
    const pot = document.getElementById("currentPot");
    const dist = document.getElementById("currentDistance");
    const mqttStateSpan = document.getElementById('mqttState');
    const modbusSlaveStateSpan = document.getElementById('modbusSlaveState');
    const modbusMasterStateSpan = document.getElementById('modbusMasterState');
    const opcServerStateSpan = document.getElementById('opcServerState');
    const opcClientStateSpan = document.getElementById('opcClientState');
    //publicadores al broker
    const digitalButton = document.getElementById('digitalControl');
    const analogForm = document.getElementById('analogControl');
    const analogInput = document.getElementById('analogValue');

    // Depuration listener
    socket.on('connect', () => {
        console.log(`[CLIENT] Connection complete with the server: ${socket.id}`);
        // Actualiza el estado de la capa MQTT para indicar que Socket.io está bien
        //mqttMsg.textContent = 'Connected to Express/Socket.io. Waiting data from the Broker...';
    });

    socket.on('disconnect', () => {
        console.log('[CLIENT] Connection lost with the server.');
        //mqttMsg.textContent = 'ERROR: Lost connection with Express/Socket.io .';
    });

    //lectura del estado mqtt
    socket.on('connect', () => {
        // Cuando el cliente se conecta a Express, asumimos que está listo
        mqttStateSpan.textContent = 'CONNECTED';
        mqttStateSpan.style.color = 'green';
    });

    socket.on('disconnect', () => {
        // Si la conexión con Express se cae, el estado es DISCONNECTED
        mqttStateSpan.textContent = 'DISCONNECTED (Server Down (Express))';
        mqttStateSpan.style.color = 'red';
    });

    // Este evento viene de mqttClient.js cuando client.on('error') se dispara
    socket.on('system_fault', (data) => {
        console.error(`[SYSTEM FAULT] Origen: ${data.source}.`);
        
        // El error más común es la pérdida de conexión con el broker
        if (data.source === 'MQTT_BROKER') {
            mqttStateSpan.textContent = 'DISCONNECTED (Broker Offline)';
            mqttStateSpan.style.color = 'red';
        }
        
        // Opcional: Notificar en la sección general de fallas (si existe)
        // document.getElementById('systemFaultMessage').textContent = data.message;
    });

    // Data reception from broker
    // Listen 'mqtt_update' event from mqttClient.js
    socket.on('mqtt_update', (data) => {
        console.log('[CLIENT] New information receipt:', data);
        
        const { topic, payload } = data;

        // upload HTML elements
        switch (topic) {
            case 'pci/sensor/pot':
                pot.textContent = payload;
                break;
            case 'pci/sensor/distancia':
                dist.textContent = payload;
                break;
            case 'pci/datos/boton_1':
                boton1.textContent = payload;
                break;
            case 'pci/datos/boton_2':
                boton2.textContent = payload;
                break;
            //ESTADISTICA
            case 'pci/estadistica/modbus_aceptadas':
                modbusAceptada.textContent = payload;
                break;
            case 'pci/estadistica/modbus_crc_error':
                modbusCRC.textContent = payload;
                break;
            case 'pci/estadistica/modbus_no_alcanzado':
                modbusNoAlcanzada.textContent = payload;
                break;
            //ESTADISTICA
            case 'pci/state/modbus_esclavo':
                modbusSlaveStateSpan.textContent = payload;
                if (payload == 'OK') {
                    modbusSlaveStateSpan.style.color = 'green'; 
                } else if (payload == 'ERROR_TIMEOUT'){
                    modbusSlaveStateSpan.style.color = 'red';
                } else if(payload == 'ERROR_DESCONECTADO'){
                    modbusSlaveStateSpan.style.color = 'red';
                }else {
                    modbusSlaveStateSpan.style.color = 'yellow';
                }
                break;
            case 'pci/state/modbus_maestro':
                modbusMasterStateSpan.textContent = payload;
                if (payload == 'RUNNING') {
                    modbusMasterStateSpan.style.color = 'green'; 
                } else if (payload == 'DEVICE NOT REACHED'){
                    modbusMasterStateSpan.style.color = 'yellow';
                } else {
                    modbusMasterStateSpan.style.color = 'red';
                }
                break;
            case 'pci/state/opc_server':
                opcServerStateSpan.textContent = payload;
                if (payload === 'CRASHED') {
                    opcServerStateSpan.style.color = 'red'; 
                } else {
                    opcServerStateSpan.style.color = 'green';
                }
                break;
            case 'pci/state/opc_cliente':
                opcClientStateSpan.textContent = payload;
                if (payload === 'CRASHED') {
                    opcClientStateSpan.style.color = 'red'; 
                } else {
                    opcClientStateSpan.style.color = 'green';
                }
                break;
            case 'pci/value1/analog':
                break;
            case 'pci/value1/dig':
                break;
            default:
                console.log(`[CLIENT] Tópico recibido no mapeado: ${topic}`);
        }
    });

    //envio de informacion al broker
    //digitales
    digitalButton.addEventListener('click', async (e) => {
    e.preventDefault(); 
    
    //Leer el estado actual del botón (0 o 1)
    const currentState = digitalButton.getAttribute('data-state');
    
    //Determinar el nuevo estado
    const newState = (currentState === '0' || currentState === 'OFF') ? '1' : '0';

    try {
        //Enviar el nuevo estado (1 o 0) al endpoint POST
        const response = await fetch('/command/digital', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ state: newState }) 
        });

        if (response.ok) {
            console.log(`Comando digital enviado: ${newState}`);
            
            //ACTUALIZAR EL ESTADO VISUAL Y DATA DEL BOTÓN
            if (newState === '1') {
                digitalButton.textContent = 'ON';
                digitalButton.classList.remove('btn-danger'); // Rojo
                digitalButton.classList.add('btn-success'); // Verde
                digitalButton.setAttribute('data-state', '1');
            } else {
                digitalButton.textContent = 'OFF';
                digitalButton.classList.remove('btn-success'); // Verde
                digitalButton.classList.add('btn-danger'); // Rojo
                digitalButton.setAttribute('data-state', '0');
            }
        } else {
            const errorData = await response.json();
            console.error("Error del servidor:", errorData.message);
        }

    } catch (error) {
        console.error('Fallo de conexión o de red:', error);
    }

    //analogicos
    analogForm.addEventListener('submit', async (e) => {
        e.preventDefault();

        const valueToSend = analogInput.value;

        try {
            const response = await fetch('/command/analog', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                // El valor debe ser enviado como un string/JSON
                body: JSON.stringify({ value: valueToSend }) 
            });

            const data = await response.json();

            if (response.ok) {
                console.log(`Comando analógico enviado: ${valueToSend}. Servidor responde:`, data.message);
                // Opcional: Mostrar un mensaje de éxito en la vista
            } else {
                console.error('Error del servidor:', data.message);
                alert(`Error al enviar comando analógico: ${data.message}`);
            }

        } catch (error) {
            console.error('Fallo en la conexión o en la red:', error);
            alert('Fallo de conexión al servidor.');
        }
        
        // Limpiar o restablecer el valor después del envío
        analogInput.value = '';
    });
});
</script>